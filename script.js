// Operating Systems Comprehensive Quiz - 60 Questions
const questions = [
    {
        id: 1,
        question: "In UNIX file permissions `-rwxr-xr--`, what does the first character represent?",
        options: [
            "Read permission for owner",
            "Regular file type",
            "Root access indicator", 
            "Recursive permission flag"
        ],
        correctAnswer: 1,
        explanation: "The first character in UNIX file permissions indicates the file type. A hyphen (-) indicates a regular file, while 'd' would indicate a directory. The remaining 9 characters represent permissions for owner, group, and others (3 characters each).",
        category: "Access Rights & File Permissions"
    },
    {
        id: 2,
        question: "What is the numeric equivalent of permissions `rwx` for the owner?",
        options: [
            "6",
            "7",
            "8",
            "9"
        ],
        correctAnswer: 1,
        explanation: "In UNIX, read=4, write=2, execute=1. So rwx = 4+2+1 = 7. This numeric notation allows quick permission setting with commands like `chmod 755 filename`.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 3,
        question: "The command `chmod go-rwx filename` will:",
        options: [
            "Give read, write, execute to group and others",
            "Remove read, write, execute from group and others",
            "Set read, write, execute for group and others",
            "Only affect the group permissions"
        ],
        correctAnswer: 1,
        explanation: "The 'go' refers to group and others, the '-' means remove, and 'rwx' are the permissions being removed. This command removes all permissions from group and other users while leaving owner permissions unchanged.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 4,
        question: "Which file system service is NOT typically provided by operating systems?",
        options: [
            "Create a file",
            "Read from an open file",
            "Compile source code",
            "Modify file metadata"
        ],
        correctAnswer: 2,
        explanation: "Compilation is handled by compilers, not the file system. File systems provide basic operations like create, read, write, open, close, and metadata management, but not language-specific operations like compilation.",
        category: "File Systems & Management"
    },
    {
        id: 5,
        question: "What is the main advantage of treating all I/O devices as files in UNIX?",
        options: [
            "Faster performance",
            "Uniform interface for all devices",
            "Better security",
            "Reduced memory usage"
        ],
        correctAnswer: 1,
        explanation: "UNIX treats terminals, disk drives, pipes, and other devices as files, providing a uniform interface. This means the same system calls (read, write, open, close) work for all devices, simplifying programming.",
        category: "File Systems & Management"
    },
    {
        id: 6,
        question: "In file locking, what is the difference between exclusive and shared access?",
        options: [
            "Exclusive allows one writer, shared allows multiple readers",
            "Exclusive is faster than shared",
            "Shared access requires more memory",
            "There is no practical difference"
        ],
        correctAnswer: 0,
        explanation: "Exclusive access prevents other processes from accessing the file (typically for writing), while shared access allows multiple processes to read simultaneously. This prevents data corruption during writes while allowing concurrent reads.",
        category: "File Systems & Management"
    },
    {
        id: 7,
        question: "What is the primary purpose of the Memory Management Unit (MMU)?",
        options: [
            "Increase memory speed",
            "Translate logical addresses to physical addresses",
            "Compress memory contents",
            "Manage cache memory"
        ],
        correctAnswer: 1,
        explanation: "The MMU translates virtual/logical addresses generated by the CPU into actual physical memory addresses. This enables virtual memory, memory protection, and allows programs to use addresses independent of their physical location.",
        category: "Memory Management"
    },
    {
        id: 8,
        question: "In fixed partition memory allocation, what is internal fragmentation?",
        options: [
            "Unused space between partitions",
            "Unused space within allocated partitions",
            "Fragmented files on disk",
            "Memory leaks in programs"
        ],
        correctAnswer: 1,
        explanation: "Internal fragmentation occurs when allocated memory blocks contain unused space. In fixed partitions, if a 100KB process is allocated to a 150KB partition, the 50KB unused space is internal fragmentation.",
        category: "Memory Management"
    },
    {
        id: 9,
        question: "What is the main advantage of dynamic address binding over static binding?",
        options: [
            "Faster execution",
            "Programs can be relocated in memory",
            "Uses less memory",
            "Simpler to implement"
        ],
        correctAnswer: 1,
        explanation: "Dynamic binding allows programs to be loaded at any memory location and moved during execution. Static binding fixes addresses at compile/link time, requiring programs to be loaded at specific memory locations.",
        category: "Memory Management"
    },
    {
        id: 10,
        question: "In paging, if logical address is 0x12345 with 4KB pages, what is the page number?",
        options: [
            "0x12",
            "0x123",
            "0x1234",
            "0x345"
        ],
        correctAnswer: 0,
        explanation: "With 4KB (4096 = 2^12) pages, the lower 12 bits (0x345) represent the offset within the page, and the upper bits (0x12) represent the page number. The page number is used for address translation.",
        category: "Memory Management"
    },
    {
        id: 11,
        question: "What is the primary benefit of virtual memory?",
        options: [
            "Faster memory access",
            "Ability to run programs larger than physical memory",
            "Better graphics performance",
            "Reduced power consumption"
        ],
        correctAnswer: 1,
        explanation: "Virtual memory allows execution of programs that exceed physical RAM size by using disk storage as an extension of memory. Pages are swapped between RAM and disk as needed.",
        category: "Virtual Memory"
    },
    {
        id: 12,
        question: "In a virtual memory system with page size 4KB, how many bits are needed for the page offset?",
        options: [
            "10 bits",
            "12 bits",
            "14 bits",
            "16 bits"
        ],
        correctAnswer: 1,
        explanation: "4KB = 4096 bytes = 2^12 bytes. Therefore, 12 bits are needed to address all bytes within a 4KB page (0 to 4095).",
        category: "Virtual Memory"
    },
    {
        id: 13,
        question: "When two logical pages map to the same physical page, this typically indicates:",
        options: [
            "A memory error",
            "Shared memory or code",
            "Virtual memory failure",
            "Page fault condition"
        ],
        correctAnswer: 1,
        explanation: "Multiple logical pages mapping to the same physical page allows processes to share code (like libraries) or data, reducing memory usage while maintaining separate virtual address spaces.",
        category: "Virtual Memory"
    },
    {
        id: 14,
        question: "What is the computational state of a process?",
        options: [
            "The process priority level",
            "Internal snapshot of CPU registers and resources at an instant",
            "The process memory usage",
            "The process execution time"
        ],
        correctAnswer: 1,
        explanation: "The computational state includes CPU registers, program counter, stack pointer, and other processor state information that must be saved when the process is switched out and restored when it resumes.",
        category: "Process Management"
    },
    {
        id: 15,
        question: "In the five-state process model, what is the difference between \"Ready\" and \"Blocked\" states?",
        options: [
            "Ready processes are running, blocked are waiting",
            "Ready processes can run immediately, blocked are waiting for I/O",
            "Ready processes have higher priority",
            "There is no practical difference"
        ],
        correctAnswer: 1,
        explanation: "Ready processes are waiting in the queue for CPU time and can run immediately when scheduled. Blocked processes are waiting for some event (like I/O completion) and cannot run until that event occurs.",
        category: "Process Management"
    },
    {
        id: 16,
        question: "What is the purpose of the \"New\" state in the five-state process model?",
        options: [
            "Process is being created but not yet ready to run",
            "Process has just started executing",
            "Process is waiting for user input",
            "Process is being terminated"
        ],
        correctAnswer: 0,
        explanation: "The New state represents processes that have been created (allocated PID, process control block) but haven't been admitted to the pool of executable processes yet, often due to system limits on concurrent processes.",
        category: "Process Management"
    },
    {
        id: 17,
        question: "Why might an operating system move a blocked process to a suspend state?",
        options: [
            "To free up memory for new processes",
            "To increase process priority",
            "To debug the process",
            "To improve security"
        ],
        correctAnswer: 0,
        explanation: "Suspending blocked processes moves them to disk storage, freeing up main memory. This allows new processes to be loaded or ready processes to have more memory available, improving overall system performance.",
        category: "Process Management"
    },
    {
        id: 18,
        question: "What is the main difference between preemptive and cooperative multitasking?",
        options: [
            "Speed of execution",
            "Whether the OS can forcibly stop running processes",
            "Number of processes that can run",
            "Memory usage"
        ],
        correctAnswer: 1,
        explanation: "In preemptive multitasking, the OS can forcibly stop (preempt) a running process to schedule another. In cooperative multitasking, processes must voluntarily yield control, which can lead to system hangs if a process doesn't cooperate.",
        category: "CPU Scheduling"
    },
    {
        id: 19,
        question: "Why does Linux favor I/O-bound processes in scheduling?",
        options: [
            "They use less memory",
            "They provide better interactive response",
            "They are more important",
            "They execute faster"
        ],
        correctAnswer: 1,
        explanation: "I/O-bound processes (like interactive applications) typically run for short bursts before waiting for I/O. Favoring them ensures quick response to user interactions, making the system feel more responsive.",
        category: "CPU Scheduling"
    },
    {
        id: 20,
        question: "What happens when a process's timeslice expires in Linux?",
        options: [
            "The process is terminated",
            "The process becomes expired and can't run until others exhaust their timeslices",
            "The process priority is lowered",
            "The process is moved to blocked state"
        ],
        correctAnswer: 1,
        explanation: "When a process uses up its timeslice, it becomes \"expired\" and cannot run until all other processes have also exhausted their timeslices, at which point all timeslices are recalculated.",
        category: "CPU Scheduling"
    },
    {
        id: 21,
        question: "Why is a very short timeslice problematic for system performance?",
        options: [
            "Processes cannot complete their work",
            "Too much time is spent on context switching overhead",
            "Memory usage increases",
            "I/O performance degrades"
        ],
        correctAnswer: 1,
        explanation: "Very short timeslices cause frequent context switches between processes. The overhead of saving and restoring process state becomes a significant portion of CPU time, reducing overall system throughput.",
        category: "CPU Scheduling"
    },
    {
        id: 22,
        question: "What is a race condition?",
        options: [
            "Competition between processes for CPU time",
            "When multiple processes access shared data and the result depends on execution order",
            "When one process runs faster than another",
            "When processes compete for memory allocation"
        ],
        correctAnswer: 1,
        explanation: "A race condition occurs when the outcome of a program depends on the relative timing or interleaving of multiple processes/threads accessing shared resources, leading to unpredictable and potentially incorrect results.",
        category: "Inter-Process Communication"
    },
    {
        id: 23,
        question: "What is the main problem that semaphores solve?",
        options: [
            "Memory allocation",
            "Process scheduling",
            "Mutual exclusion and synchronization",
            "File system access"
        ],
        correctAnswer: 2,
        explanation: "Semaphores provide a mechanism for controlling access to shared resources, ensuring mutual exclusion (only one process in critical section) and enabling process synchronization for coordinated execution.",
        category: "Inter-Process Communication"
    },
    {
        id: 24,
        question: "In the context of the three types of process interaction, which is the most complex to manage?",
        options: [
            "Processes competing for resources",
            "Processes cooperating by communication",
            "Independent processes",
            "All are equally complex"
        ],
        correctAnswer: 1,
        explanation: "Cooperating processes that share data and communicate are most complex because they require careful synchronization to avoid race conditions, deadlocks, and ensure data consistency while maintaining correct communication protocols.",
        category: "Inter-Process Communication"
    },
    {
        id: 25,
        question: "What is the difference between synchronous and asynchronous signals?",
        options: [
            "Synchronous signals are faster",
            "Synchronous signals occur at predictable points, asynchronous are random",
            "Asynchronous signals are more important",
            "Synchronous signals require special hardware"
        ],
        correctAnswer: 1,
        explanation: "Synchronous signals (like divide-by-zero, illegal instruction) occur at specific, predictable points in program execution. Asynchronous signals (like SIGINT from Ctrl+C, timer expiration) can occur at any time unpredictably.",
        category: "Signals"
    },
    {
        id: 26,
        question: "What does the signal() function call `signal(SIGINT, SIG_IGN)` do?",
        options: [
            "Catches SIGINT with a custom handler",
            "Ignores SIGINT signals",
            "Restores default SIGINT behavior",
            "Sends SIGINT to another process"
        ],
        correctAnswer: 1,
        explanation: "SIG_IGN tells the system to ignore the specified signal (SIGINT in this case). The process will continue running even when SIGINT is received, such as when Ctrl+C is pressed.",
        category: "Signals"
    },
    {
        id: 27,
        question: "Which signal cannot be caught or ignored?",
        options: [
            "SIGINT",
            "SIGTERM",
            "SIGKILL",
            "SIGALARM"
        ],
        correctAnswer: 2,
        explanation: "SIGKILL cannot be caught, ignored, or blocked by a process. It provides a guaranteed way for the system or users to terminate processes that are not responding to other termination signals.",
        category: "Signals"
    },
    {
        id: 28,
        question: "What typically happens when Ctrl+C is pressed in a terminal?",
        options: [
            "SIGTERM is sent to the foreground process",
            "SIGINT is sent to the foreground process",
            "SIGKILL is sent to all processes",
            "SIGHUP is sent to the shell"
        ],
        correctAnswer: 1,
        explanation: "Ctrl+C generates a SIGINT (interrupt) signal that is sent to the foreground process group. The default action is to terminate the process, but programs can catch this signal to perform cleanup operations.",
        category: "Signals"
    },
    {
        id: 29,
        question: "What is a pipe in UNIX?",
        options: [
            "A hardware component",
            "A file used as a communication buffer between processes",
            "A memory allocation technique",
            "A process scheduling algorithm"
        ],
        correctAnswer: 1,
        explanation: "A pipe is a special file that acts as a queuing buffer, allowing the output of one process to serve as input to another process, enabling inter-process communication through a FIFO (first-in-first-out) mechanism.",
        category: "IPC Mechanisms"
    },
    {
        id: 30,
        question: "In the command `ls | grep txt`, what is the role of the pipe?",
        options: [
            "It stores the output permanently",
            "It connects the output of ls to the input of grep",
            "It sorts the output",
            "It filters duplicate entries"
        ],
        correctAnswer: 1,
        explanation: "The pipe (|) connects the standard output of the `ls` command to the standard input of `grep txt`, allowing grep to filter the directory listing to show only files containing \"txt\" in their names.",
        category: "IPC Mechanisms"
    },
    {
        id: 31,
        question: "What are the three main components of System V IPC?",
        options: [
            "Pipes, signals, and sockets",
            "Semaphores, message queues, and shared memory",
            "Files, directories, and devices",
            "Processes, threads, and tasks"
        ],
        correctAnswer: 1,
        explanation: "System V IPC provides three main mechanisms: semaphores for synchronization, message queues for message passing, and shared memory for high-speed data sharing between processes.",
        category: "IPC Mechanisms"
    },
    {
        id: 32,
        question: "What is the main advantage of shared memory over message passing?",
        options: [
            "Better security",
            "Easier to use",
            "Higher performance/speed",
            "More reliable"
        ],
        correctAnswer: 2,
        explanation: "Shared memory allows processes to communicate by directly accessing shared memory regions, avoiding the overhead of copying data through kernel buffers that message passing requires, making it the fastest IPC mechanism.",
        category: "IPC Mechanisms"
    },
    {
        id: 33,
        question: "What are the four necessary conditions for deadlock?",
        options: [
            "Mutual exclusion, hold and wait, no preemption, circular wait",
            "Competition, cooperation, communication, coordination",
            "Create, read, update, delete",
            "Ready, running, blocked, suspended"
        ],
        correctAnswer: 0,
        explanation: "These four conditions must all be present for deadlock: resources must be mutually exclusive, processes hold resources while waiting for others, resources cannot be preempted, and there must be a circular chain of processes waiting for each other's resources.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 34,
        question: "Which deadlock prevention strategy involves resource preemption?",
        options: [
            "Eliminating mutual exclusion",
            "Eliminating hold and wait",
            "Eliminating no preemption",
            "Eliminating circular wait"
        ],
        correctAnswer: 2,
        explanation: "Eliminating the \"no preemption\" condition means allowing the system to forcibly take resources away from processes, though this is only practical for certain types of resources like CPU time, not for resources like printers.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 35,
        question: "What is the main advantage of hierarchical directory structures over flat directories?",
        options: [
            "Faster file access",
            "Better organization and namespace management",
            "Less memory usage",
            "Improved security"
        ],
        correctAnswer: 1,
        explanation: "Hierarchical directories allow logical organization of files into groups and enable the same filename to exist in different directories, effectively expanding the namespace and making file management more organized.",
        category: "File Organization"
    },
    {
        id: 36,
        question: "In UNIX, what does the root directory \"/\" represent?",
        options: [
            "The current user's home directory",
            "The top-level directory of the entire file system",
            "The system configuration directory",
            "The temporary files directory"
        ],
        correctAnswer: 1,
        explanation: "The root directory (/) is the top-level directory in UNIX file systems. All other directories and files are contained within this directory structure, forming a single unified tree hierarchy.",
        category: "File Organization"
    },
    {
        id: 37,
        question: "What is the purpose of device drivers in operating systems?",
        options: [
            "To speed up device access",
            "To provide device-specific interfaces to the generic I/O subsystem",
            "To encrypt device communications",
            "To manage device power consumption"
        ],
        correctAnswer: 1,
        explanation: "Device drivers act as translators between the generic I/O subsystem and specific hardware devices, hiding device-specific details and providing a uniform interface that the operating system can use.",
        category: "I/O & Device Management"
    },
    {
        id: 38,
        question: "Why does UNIX treat devices as files?",
        options: [
            "To save memory",
            "To provide uniform access methods for all I/O",
            "To improve performance",
            "To enhance security"
        ],
        correctAnswer: 1,
        explanation: "By representing devices as special files in the file system, UNIX allows the same system calls (open, read, write, close) to work with files, terminals, printers, and other devices, simplifying programming and system design.",
        category: "I/O & Device Management"
    },
    {
        id: 39,
        question: "How do base and limit registers provide memory protection?",
        options: [
            "By encrypting memory contents",
            "By checking that all memory accesses fall within allocated bounds",
            "By compressing memory to save space",
            "By speeding up memory access"
        ],
        correctAnswer: 1,
        explanation: "The base register contains the starting address of a process's memory region, and the limit register contains the size. The MMU checks that all memory references fall within [base, base+limit) to prevent processes from accessing each other's memory.",
        category: "Memory Protection"
    },
    {
        id: 40,
        question: "What is the primary purpose of memory segmentation?",
        options: [
            "To increase memory speed",
            "To provide logical division of memory spaces",
            "To reduce memory usage",
            "To simplify programming"
        ],
        correctAnswer: 1,
        explanation: "Segmentation divides a program's memory into logical segments (code, data, stack, heap) with different properties and protection levels, providing better organization and security than a single linear address space.",
        category: "Memory Protection"
    },
    {
        id: 41,
        question: "What is the main difference between system calls and library functions?",
        options: [
            "System calls are faster",
            "System calls require kernel mode transition, library functions don't",
            "Library functions are more secure",
            "System calls use less memory"
        ],
        correctAnswer: 1,
        explanation: "System calls require switching from user mode to kernel mode to access operating system services, while library functions execute entirely in user mode. This makes system calls more expensive but necessary for accessing protected resources.",
        category: "System Calls"
    },
    {
        id: 42,
        question: "Which of the following is typically implemented as a system call?",
        options: [
            "Mathematical calculations",
            "String manipulation",
            "File creation",
            "Sorting algorithms"
        ],
        correctAnswer: 2,
        explanation: "File creation requires operating system intervention to allocate disk space, update directory structures, and set up file metadata, making it a system call. The other operations can be performed entirely in user space.",
        category: "System Calls"
    },
    {
        id: 43,
        question: "What is the critical section problem?",
        options: [
            "Running out of memory",
            "Multiple processes accessing shared resources without proper synchronization",
            "Process scheduling conflicts",
            "File system corruption"
        ],
        correctAnswer: 1,
        explanation: "The critical section problem involves ensuring that when multiple processes access shared resources, only one process can be in its critical section (the code segment accessing shared resources) at any time to prevent data corruption.",
        category: "Process Synchronization"
    },
    {
        id: 44,
        question: "What is a mutex?",
        options: [
            "A type of process",
            "A binary semaphore for mutual exclusion",
            "A memory allocation technique",
            "A file locking mechanism"
        ],
        correctAnswer: 1,
        explanation: "A mutex (mutual exclusion) is a synchronization primitive that acts like a binary semaphore (0 or 1) to ensure that only one thread or process can access a shared resource at a time.",
        category: "Process Synchronization"
    },
    {
        id: 45,
        question: "What is thrashing in virtual memory systems?",
        options: [
            "Excessive page faulting that degrades performance",
            "Memory corruption",
            "Process termination",
            "Disk fragmentation"
        ],
        correctAnswer: 0,
        explanation: "Thrashing occurs when a system spends more time swapping pages between memory and disk than executing useful work, typically due to insufficient physical memory relative to the working set sizes of active processes.",
        category: "Performance & Optimization"
    },
    {
        id: 46,
        question: "What is locality of reference?",
        options: [
            "Memory addresses are randomly distributed",
            "Programs tend to access memory locations near recently accessed locations",
            "All processes use the same memory locations",
            "Memory is allocated sequentially"
        ],
        correctAnswer: 1,
        explanation: "Locality of reference includes spatial locality (accessing nearby memory locations) and temporal locality (accessing recently used locations again). This principle is crucial for the effectiveness of caches and virtual memory systems.",
        category: "Performance & Optimization"
    },
    {
        id: 47,
        question: "What is the main challenge in distributed operating systems?",
        options: [
            "Limited processing power",
            "Coordinating processes across multiple machines",
            "Insufficient memory",
            "Slow networks"
        ],
        correctAnswer: 1,
        explanation: "Distributed systems must handle coordination, synchronization, and communication between processes running on different machines connected by networks, dealing with issues like network delays, failures, and partitions.",
        category: "Distributed Systems"
    },
    {
        id: 48,
        question: "What distinguishes real-time operating systems from general-purpose operating systems?",
        options: [
            "Higher processing speed",
            "Guaranteed response times for critical tasks",
            "Better graphics support",
            "More memory capacity"
        ],
        correctAnswer: 1,
        explanation: "Real-time operating systems provide deterministic timing guarantees, ensuring that critical tasks complete within specified deadlines. This is essential for applications like medical devices, automotive systems, and industrial control.",
        category: "Real-time Systems"
    },
    {
        id: 49,
        question: "What is the primary function of a bootloader?",
        options: [
            "To manage memory",
            "To load the operating system kernel into memory",
            "To handle user login",
            "To manage network connections"
        ],
        correctAnswer: 1,
        explanation: "The bootloader is responsible for loading the operating system kernel from storage into memory and transferring control to it. This is one of the first steps in the computer boot process after hardware initialization.",
        category: "Boot Process"
    },
    {
        id: 50,
        question: "What is copy-on-write (COW)?",
        options: [
            "A file backup technique",
            "A memory optimization where pages are copied only when modified",
            "A network protocol",
            "A disk compression method"
        ],
        correctAnswer: 1,
        explanation: "Copy-on-write allows multiple processes to share the same physical memory pages until one process tries to modify a page, at which point a private copy is made. This saves memory and improves fork() performance.",
        category: "Advanced Memory Management"
    },
    {
        id: 51,
        question: "What is the purpose of an inode in UNIX file systems?",
        options: [
            "To store file data",
            "To store file metadata and disk block pointers",
            "To manage user permissions",
            "To handle network connections"
        ],
        correctAnswer: 1,
        explanation: "An inode (index node) contains file metadata such as size, permissions, timestamps, and pointers to the disk blocks containing the file's data. The filename is stored in directory entries that point to inodes.",
        category: "File System Implementation"
    },
    {
        id: 52,
        question: "What is journaling in file systems?",
        options: [
            "A backup technique",
            "Recording file system changes in a log before applying them",
            "A compression method",
            "A user activity monitoring system"
        ],
        correctAnswer: 1,
        explanation: "Journaling file systems write metadata changes to a journal (log) before applying them to the main file system structures. This allows quick recovery after system crashes by replaying or undoing incomplete operations.",
        category: "File System Implementation"
    },
    {
        id: 53,
        question: "What is the principle of least privilege?",
        options: [
            "Users should have maximum access for convenience",
            "Users should have only the minimum access necessary for their tasks",
            "All users should have equal access",
            "Access should be randomly distributed"
        ],
        correctAnswer: 1,
        explanation: "The principle of least privilege states that users and processes should be granted only the minimum level of access or permissions needed to perform their legitimate functions, reducing security risks.",
        category: "Security"
    },
    {
        id: 54,
        question: "What is a buffer overflow attack?",
        options: [
            "Running out of disk space",
            "Exploiting programs that don't check input buffer boundaries",
            "Network congestion",
            "Memory leaks"
        ],
        correctAnswer: 1,
        explanation: "Buffer overflow attacks occur when programs write more data to a buffer than it can hold, potentially overwriting adjacent memory areas. Attackers can exploit this to inject malicious code or alter program execution.",
        category: "Security"
    },
    {
        id: 55,
        question: "What is containerization?",
        options: [
            "A backup storage method",
            "Lightweight virtualization using OS-level isolation",
            "A file compression technique",
            "A network security protocol"
        ],
        correctAnswer: 1,
        explanation: "Containerization provides isolated execution environments that share the same OS kernel but have separate user spaces, file systems, and network interfaces. It's lighter weight than full virtualization while still providing isolation.",
        category: "Modern OS Features"
    },
    {
        id: 56,
        question: "What is the main advantage of microkernel architecture over monolithic kernels?",
        options: [
            "Better performance",
            "Improved modularity and fault isolation",
            "Less memory usage",
            "Faster boot times"
        ],
        correctAnswer: 1,
        explanation: "Microkernels move most OS services to user-space servers, keeping only essential functions (IPC, basic scheduling, memory management) in kernel space. This improves modularity and prevents service failures from crashing the entire system.",
        category: "Modern OS Features"
    },
    {
        id: 57,
        question: "What does the `ps` command show in UNIX systems?",
        options: [
            "Disk space usage",
            "Currently running processes",
            "Network connections",
            "File permissions"
        ],
        correctAnswer: 1,
        explanation: "The `ps` command displays information about currently running processes, including process IDs, CPU usage, memory usage, and command names. Different options provide various levels of detail and filtering.",
        category: "Performance Monitoring"
    },
    {
        id: 58,
        question: "What is the purpose of the `top` command?",
        options: [
            "To display the directory tree",
            "To show real-time system performance and process information",
            "To manage file permissions",
            "To configure network settings"
        ],
        correctAnswer: 1,
        explanation: "The `top` command provides a dynamic, real-time view of system performance, showing CPU usage, memory usage, running processes, and system load averages, updating the display periodically.",
        category: "Performance Monitoring"
    },
    {
        id: 59,
        question: "What is swappiness in Linux?",
        options: [
            "A network configuration parameter",
            "A parameter controlling how aggressively the system swaps memory to disk",
            "A file system type",
            "A process priority setting"
        ],
        correctAnswer: 1,
        explanation: "Swappiness is a Linux kernel parameter (0-100) that controls the tendency to swap memory pages to disk. Lower values make the kernel avoid swapping, while higher values make it more likely to swap pages to free RAM.",
        category: "System Optimization"
    },
    {
        id: 60,
        question: "What is the working set of a process?",
        options: [
            "The CPU registers used by the process",
            "The set of memory pages the process is actively using",
            "The files opened by the process",
            "The child processes created by the process"
        ],
        correctAnswer: 1,
        explanation: "The working set is the collection of memory pages that a process references during a given time interval. Understanding working sets is crucial for memory management decisions and preventing thrashing in virtual memory systems.",
        category: "System Optimization"
    },
    {
        id: 61,
        question: "Which command would you use to view detailed permissions for all files in a directory?",
        options: [
            "chmod",
            "ls -l",
            "cat",
            "ps"
        ],
        correctAnswer: 1,
        explanation: "The `ls -l` command lists files in long format, showing permissions, ownership, size, and modification date for each file.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 62,
        question: "In UNIX, what does the command `chmod 600 myfile` do?",
        options: [
            "Gives everyone full access to myfile",
            "Owner can read/write, others have no access",
            "Owner can only read, others can write",
            "Group can execute, owner cannot"
        ],
        correctAnswer: 1,
        explanation: "6 = read+write for owner, 0 = no permissions for group and others.",
        category: "Access Rights & File Permissions"
    },
    {
        id: 63,
        question: "What is the main purpose of file metadata?",
        options: [
            "Store the file's actual data",
            "Store information about the file (size, permissions, timestamps)",
            "Encrypt the file",
            "Compress the file"
        ],
        correctAnswer: 1,
        explanation: "Metadata describes the file's properties, not its content.",
        category: "File Systems & Management"
    },
    {
        id: 64,
        question: "Which of the following is NOT a valid UNIX file type?",
        options: [
            "Directory",
            "Regular file",
            "Device file",
            "Spreadsheet file"
        ],
        correctAnswer: 3,
        explanation: "UNIX recognizes regular files, directories, device files, and pipes, but not application-specific types like spreadsheets.",
        category: "File Systems & Management"
    },
    {
        id: 65,
        question: "What is the main advantage of dynamic memory allocation over fixed partitioning?",
        options: [
            "Simpler implementation",
            "Reduces internal fragmentation",
            "Increases external fragmentation",
            "Prevents all fragmentation"
        ],
        correctAnswer: 1,
        explanation: "Dynamic allocation matches memory to process needs, reducing wasted space inside partitions.",
        category: "Memory Management"
    },
    {
        id: 66,
        question: "What is a page fault?",
        options: [
            "When a process tries to access a page not in physical memory",
            "When a process divides by zero",
            "When a file cannot be found",
            "When a process is blocked"
        ],
        correctAnswer: 0,
        explanation: "The OS must load the required page from disk into RAM, which can slow down execution.",
        category: "Virtual Memory"
    },
    {
        id: 67,
        question: "Which process state is responsible for waiting for I/O completion?",
        options: [
            "Ready",
            "Running",
            "Blocked",
            "New"
        ],
        correctAnswer: 2,
        explanation: "Blocked processes are waiting for an event, such as I/O, to complete before they can continue.",
        category: "Process Management"
    },
    {
        id: 68,
        question: "What is the main function of the Process Control Block (PCB)?",
        options: [
            "Store the process's executable code",
            "Track the process's state and resources",
            "Manage device drivers",
            "Handle file permissions"
        ],
        correctAnswer: 1,
        explanation: "The PCB contains information like process state, program counter, CPU registers, memory management info, and open files.",
        category: "Process Management"
    },
    {
        id: 69,
        question: "Which scheduling goal is most important for interactive systems?",
        options: [
            "High throughput",
            "Low latency",
            "Fairness",
            "High CPU utilization"
        ],
        correctAnswer: 1,
        explanation: "Interactive systems prioritize quick response to user actions, which requires low latency.",
        category: "CPU Scheduling"
    },
    {
        id: 70,
        question: "What is the effect of setting a very high swappiness value in Linux?",
        options: [
            "The system will avoid swapping",
            "The system will swap aggressively",
            "The system will crash",
            "The system will ignore swap space"
        ],
        correctAnswer: 1,
        explanation: "High swappiness means the kernel will move processes to swap space more readily to free up RAM.",
        category: "System Optimization"
    },
    {
        id: 71,
        question: "Which of the following is a scenario where a race condition can occur?",
        options: [
            "Two processes reading the same file",
            "Two processes writing to the same variable without synchronization",
            "One process waiting for I/O",
            "A process running in user mode"
        ],
        correctAnswer: 1,
        explanation: "Without proper synchronization, the final value depends on the order of execution, leading to unpredictable results.",
        category: "Inter-Process Communication"
    },
    {
        id: 72,
        question: "What is the main role of a semaphore in process synchronization?",
        options: [
            "To allocate memory",
            "To control access to shared resources",
            "To schedule processes",
            "To manage device drivers"
        ],
        correctAnswer: 1,
        explanation: "Semaphores are used to implement mutual exclusion and coordinate process execution.",
        category: "Process Synchronization"
    },
    {
        id: 73,
        question: "Which IPC mechanism is best for high-speed data sharing between processes?",
        options: [
            "Pipes",
            "Message queues",
            "Shared memory",
            "Signals"
        ],
        correctAnswer: 2,
        explanation: "Shared memory allows processes to access the same memory region directly, making it the fastest IPC method.",
        category: "IPC Mechanisms"
    },
    {
        id: 74,
        question: "What does the signal SIGKILL do?",
        options: [
            "Requests a process to terminate gracefully",
            "Forces a process to terminate immediately",
            "Ignores the process",
            "Suspends the process"
        ],
        correctAnswer: 1,
        explanation: "SIGKILL cannot be caught or ignored and guarantees process termination.",
        category: "Signals"
    },
    {
        id: 75,
        question: "Which of the following is a necessary condition for deadlock?",
        options: [
            "Preemption",
            "Circular wait",
            "Shared memory",
            "High CPU utilization"
        ],
        correctAnswer: 1,
        explanation: "Deadlock requires mutual exclusion, hold and wait, no preemption, and circular wait.",
        category: "Synchronization & Deadlocks"
    },
    {
        id: 76,
        question: "What is the main difference between block and character devices?",
        options: [
            "Block devices transfer data in fixed-size blocks; character devices transfer data as streams",
            "Block devices are slower",
            "Character devices are only for input",
            "Block devices cannot be used for storage"
        ],
        correctAnswer: 0,
        explanation: "Disks are block devices; keyboards and mice are character devices.",
        category: "I/O & Device Management"
    },
    {
        id: 77,
        question: "What is the purpose of a device driver?",
        options: [
            "To provide a uniform interface between hardware and software",
            "To increase device speed",
            "To encrypt device data",
            "To manage user permissions"
        ],
        correctAnswer: 0,
        explanation: "Device drivers translate generic OS requests into device-specific commands.",
        category: "I/O & Device Management"
    },
    {
        id: 78,
        question: "Which of the following is a system call?",
        options: [
            "printf()",
            "open()",
            "sqrt()",
            "strcpy()"
        ],
        correctAnswer: 1,
        explanation: "open() is a system call for opening files; printf(), sqrt(), and strcpy() are library functions.",
        category: "System Calls"
    },
    {
        id: 79,
        question: "Why are system calls more expensive than library functions?",
        options: [
            "They require a mode switch from user to kernel mode",
            "They use more memory",
            "They are written in assembly language",
            "They are slower to compile"
        ],
        correctAnswer: 0,
        explanation: "System calls involve saving/restoring registers, changing memory mappings, and security checks.",
        category: "System Calls"
    },
    {
        id: 80,
        question: "What is thrashing?",
        options: [
            "When the system spends most of its time swapping pages in and out of memory",
            "When a process is blocked",
            "When the CPU overheats",
            "When a device driver fails"
        ],
        correctAnswer: 0,
        explanation: "Thrashing occurs when there is insufficient physical memory and the working set of processes cannot fit in RAM.",
        category: "Performance & Optimization"
    },
    {
        id: 81,
        question: "What is the principle of least privilege?",
        options: [
            "Give users maximum access",
            "Give users only the access they need",
            "Allow all users to be administrators",
            "Deny all access by default"
        ],
        correctAnswer: 1,
        explanation: "This principle reduces the risk of accidental or malicious damage.",
        category: "Security"
    },
    {
        id: 82,
        question: "What is a buffer overflow?",
        options: [
            "When a process uses too much CPU",
            "When data exceeds the storage capacity of a buffer and overwrites adjacent memory",
            "When a device driver fails",
            "When a process is blocked"
        ],
        correctAnswer: 1,
        explanation: "Buffer overflows can lead to security vulnerabilities and program crashes.",
        category: "Security"
    },
    {
        id: 83,
        question: "Which kernel architecture provides better fault isolation?",
        options: [
            "Monolithic kernel",
            "Microkernel",
            "Hybrid kernel",
            "Exokernel"
        ],
        correctAnswer: 1,
        explanation: "Microkernels run most services in user space, so faults in those services do not crash the whole system.",
        category: "Modern OS Features"
    },
    {
        id: 84,
        question: "What is the main advantage of containerization over traditional virtualization?",
        options: [
            "Each container has its own kernel",
            "Containers are more lightweight and share the host OS kernel",
            "Containers require more resources",
            "Containers are slower to start"
        ],
        correctAnswer: 1,
        explanation: "Containers use OS-level virtualization, making them faster and more resource-efficient than full VMs.",
        category: "Modern OS Features"
    },
    {
        id: 85,
        question: "What is the first step in the boot process of a modern computer?",
        options: [
            "Kernel initialization",
            "BIOS/UEFI hardware initialization",
            "Bootloader loads the kernel",
            "User login"
        ],
        correctAnswer: 1,
        explanation: "The BIOS/UEFI initializes hardware and then loads the bootloader.",
        category: "Boot Process"
    },
    {
        id: 86,
        question: "Which of the following is a quick way to check currently running processes in UNIX?",
        options: [
            "ls",
            "ps",
            "chmod",
            "cat"
        ],
        correctAnswer: 1,
        explanation: "The `ps` command lists currently running processes and their details.",
        category: "Performance Monitoring"
    },
    {
        id: 87,
        question: "What is the main function of the MMU (Memory Management Unit)?",
        options: [
            "Encrypt memory",
            "Translate logical addresses to physical addresses",
            "Manage device drivers",
            "Handle file permissions"
        ],
        correctAnswer: 1,
        explanation: "The MMU enables virtual memory and memory protection by mapping logical to physical addresses.",
        category: "Memory Management"
    },
    {
        id: 88,
        question: "What is a context switch?",
        options: [
            "Changing from one device driver to another",
            "Saving the state of one process and loading the state of another",
            "Switching from user mode to kernel mode",
            "Changing file permissions"
        ],
        correctAnswer: 1,
        explanation: "Context switching allows multitasking by letting the CPU switch between processes.",
        category: "Process Management"
    },
    {
        id: 89,
        question: "Which of the following is NOT a benefit of virtual memory?",
        options: [
            "Ability to run programs larger than physical RAM",
            "Simplified programming",
            "Increased CPU speed",
            "Memory protection"
        ],
        correctAnswer: 2,
        explanation: "Virtual memory does not make the CPU faster; it enables larger programs and better memory management.",
        category: "Virtual Memory"
    },
    {
        id: 90,
        question: "What is the main purpose of the fork() system call in UNIX?",
        options: [
            "To terminate a process",
            "To create a new process",
            "To allocate memory",
            "To open a file"
        ],
        correctAnswer: 1,
        explanation: "fork() creates a child process that is a copy of the parent.",
        category: "Process Management"
    },
    {
        id: 91,
        question: "Which of the following is a real-time system requirement?",
        options: [
            "High throughput",
            "Deterministic response time",
            "Large memory capacity",
            "User-friendly interface"
        ],
        correctAnswer: 1,
        explanation: "Real-time systems must guarantee that tasks complete within strict timing constraints.",
        category: "Real-time Systems"
    },
    {
        id: 92,
        question: "What is the main difference between authentication and authorization?",
        options: [
            "Authentication is about who you are; authorization is about what you can do",
            "Authorization is about who you are; authentication is about what you can do",
            "Both are the same",
            "Neither is important in OS"
        ],
        correctAnswer: 0,
        explanation: "Authentication verifies identity; authorization determines access rights.",
        category: "Security"
    },
    {
        id: 93,
        question: "What is the function of the exec() system call?",
        options: [
            "To create a new process",
            "To replace the current process image with a new program",
            "To terminate a process",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "exec() loads a new program into the current process, replacing its code and data.",
        category: "System Calls"
    },
    {
        id: 94,
        question: "Which of the following is a benefit of using pipes for IPC?",
        options: [
            "Allows bidirectional communication by default",
            "Provides a simple way to connect the output of one process to the input of another",
            "Requires shared memory",
            "Is only available in Windows"
        ],
        correctAnswer: 1,
        explanation: "Pipes are unidirectional and are commonly used to chain commands in UNIX.",
        category: "IPC Mechanisms"
    },
    {
        id: 95,
        question: "What is the main purpose of the init process in UNIX?",
        options: [
            "To manage device drivers",
            "To start all other user-space processes after the kernel boots",
            "To handle file permissions",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "init (or its modern equivalents) is the first user-space process and manages system startup.",
        category: "Boot Process"
    },
    {
        id: 96,
        question: "What is the main difference between spatial and temporal locality?",
        options: [
            "Spatial locality is about accessing nearby locations; temporal locality is about accessing recently used locations",
            "Spatial locality is about time; temporal locality is about space",
            "Both refer to the same concept",
            "Neither is important in OS"
        ],
        correctAnswer: 0,
        explanation: "Both are principles that make caching and virtual memory effective.",
        category: "Performance & Optimization"
    },
    {
        id: 97,
        question: "What is the main advantage of using a microkernel?",
        options: [
            "All services run in kernel space",
            "Faults in user-space services do not crash the whole system",
            "It is slower than monolithic kernels",
            "It uses more memory"
        ],
        correctAnswer: 1,
        explanation: "Microkernels improve fault isolation by running most services in user space.",
        category: "Modern OS Features"
    },
    {
        id: 98,
        question: "What is the main function of the bootloader?",
        options: [
            "To initialize hardware",
            "To load the operating system kernel into memory",
            "To manage user logins",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "The bootloader loads the kernel after hardware initialization.",
        category: "Boot Process"
    },
    {
        id: 99,
        question: "What is the main purpose of stack canaries?",
        options: [
            "To speed up process creation",
            "To detect buffer overflows",
            "To manage device drivers",
            "To allocate memory"
        ],
        correctAnswer: 1,
        explanation: "Stack canaries are special values placed on the stack to detect overwrites caused by buffer overflows.",
        category: "Security"
    },
    {
        id: 100,
        question: "What is the main benefit of using address space randomization?",
        options: [
            "To make programs run faster",
            "To make it harder for attackers to predict memory locations",
            "To increase memory usage",
            "To simplify programming"
        ],
        correctAnswer: 1,
        explanation: "Address space randomization is a security technique that makes exploits more difficult by randomizing memory layout.",
        category: "Security"
    }
];

// Quiz state variables
let currentQuestionIndex = 0;
let userAnswers = [];
let score = 0;
let quizStarted = false;
let currentMode = 'quiz'; // 'quiz' or 'notes'

// DOM Elements
const quizContainer = document.querySelector('.quiz-container');
const notesSection = document.querySelector('.notes-section');
const questionSection = document.querySelector('.question-section');
const questionText = document.getElementById('question-text');
const optionsSection = document.querySelector('.options-section');
const explanationSection = document.querySelector('.explanation-section');
const nextBtn = document.getElementById('next-btn');
const prevBtn = document.getElementById('prev-btn');
const submitBtn = document.getElementById('submit-btn');
const showAnswerBtn = document.getElementById('show-answer-btn');
const resultsSection = document.querySelector('.results-section');
const restartBtn = document.getElementById('restart-btn');
const reviewBtn = document.getElementById('review-btn');
const progressBar = document.querySelector('.progress');
const questionCounter = document.querySelector('.question-counter');

// Navigation buttons
const quizBtn = document.getElementById('quiz-btn');
const notesBtn = document.getElementById('notes-btn');

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
    setupEventListeners();
});

function initializeApp() {
    showQuizMode();
    startQuiz();
}

function setupEventListeners() {
    // Navigation buttons
    quizBtn.addEventListener('click', showQuizMode);
    notesBtn.addEventListener('click', showNotesMode);
    
    // Quiz navigation buttons
    nextBtn.addEventListener('click', nextQuestion);
    prevBtn.addEventListener('click', prevQuestion);
    submitBtn.addEventListener('click', submitQuiz);
    showAnswerBtn.addEventListener('click', showAnswer);
    restartBtn.addEventListener('click', restartQuiz);
    reviewBtn.addEventListener('click', reviewAnswers);
}

function showQuizMode() {
    currentMode = 'quiz';
    quizContainer.style.display = 'block';
    notesSection.style.display = 'none';
    
    // Update navigation buttons
    quizBtn.classList.add('active');
    notesBtn.classList.remove('active');
}

function showNotesMode() {
    currentMode = 'notes';
    quizContainer.style.display = 'none';
    notesSection.style.display = 'block';
    
    // Update navigation buttons
    notesBtn.classList.add('active');
    quizBtn.classList.remove('active');
}

function startQuiz() {
    currentQuestionIndex = 0;
    userAnswers = new Array(questions.length).fill(null);
    score = 0;
    quizStarted = true;
    
    hideResults();
    showQuestion();
    updateProgress();
    updateButtons();
}

function showQuestion() {
    const question = questions[currentQuestionIndex];
    
    // Update question text
    questionText.innerHTML = `
        <span class="question-number">Question ${currentQuestionIndex + 1}</span>
        <span class="question-category">[${question.category}]</span>
        <br>
        ${question.question}
    `;
    
    // Clear and populate options
    optionsSection.innerHTML = '';
    question.options.forEach((option, index) => {
        const optionElement = createOptionElement(option, index);
        optionsSection.appendChild(optionElement);
    });
    
    // Hide explanation initially
    explanationSection.style.display = 'none';
    
    // Restore user's previous selection
    if (userAnswers[currentQuestionIndex] !== null) {
        selectOption(userAnswers[currentQuestionIndex]);
        showAnswer();
    }
}

function createOptionElement(optionText, index) {
    const optionDiv = document.createElement('div');
    optionDiv.className = 'option';
    optionDiv.innerHTML = `
        <span class="option-letter">${String.fromCharCode(65 + index)}</span>
        <span class="option-text">${optionText}</span>
    `;
    
    optionDiv.addEventListener('click', () => selectOption(index));
    return optionDiv;
}

function selectOption(selectedIndex) {
    // Remove previous selections
    document.querySelectorAll('.option').forEach(option => {
        option.classList.remove('selected');
    });
    
    // Add selection to clicked option
    const selectedOption = document.querySelectorAll('.option')[selectedIndex];
    selectedOption.classList.add('selected');
    
    // Store the answer
    userAnswers[currentQuestionIndex] = selectedIndex;
    
    // Update buttons
    updateButtons();
}

function showAnswer() {
    const question = questions[currentQuestionIndex];
    const userAnswer = userAnswers[currentQuestionIndex];
    
    if (userAnswer === null) return;
    
    // Show correct and incorrect answers
    document.querySelectorAll('.option').forEach((option, index) => {
        if (index === question.correctAnswer) {
            option.classList.add('correct');
        } else if (index === userAnswer && index !== question.correctAnswer) {
            option.classList.add('incorrect');
        }
    });
    
    // Show explanation
    explanationSection.innerHTML = `
        <h3>Explanation:</h3>
        <p>${question.explanation}</p>
    `;
    explanationSection.style.display = 'block';
    
    // Hide show answer button
    showAnswerBtn.style.display = 'none';
}

function nextQuestion() {
    if (currentQuestionIndex < questions.length - 1) {
        currentQuestionIndex++;
        showQuestion();
        updateProgress();
        updateButtons();
    }
}

function prevQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        showQuestion();
        updateProgress();
        updateButtons();
    }
}

function updateProgress() {
    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
    progressBar.style.width = `${progress}%`;
    questionCounter.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
}

function updateButtons() {
    const hasAnswer = userAnswers[currentQuestionIndex] !== null;
    const isLastQuestion = currentQuestionIndex === questions.length - 1;
    
    // Previous button
    prevBtn.disabled = currentQuestionIndex === 0;
    
    // Next button
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-block' : 'none';
    } else {
        nextBtn.style.display = 'inline-block';
        submitBtn.style.display = 'none';
    }
    
    // Show answer button
    showAnswerBtn.style.display = hasAnswer && explanationSection.style.display === 'none' ? 'inline-block' : 'none';
}

function submitQuiz() {
    calculateScore();
    showResults();
}

function calculateScore() {
    score = 0;
    questions.forEach((question, index) => {
        if (userAnswers[index] === question.correctAnswer) {
            score++;
        }
    });
}

function showResults() {
    questionSection.style.display = 'none';
    resultsSection.style.display = 'block';
    
    const percentage = Math.round((score / questions.length) * 100);
    let grade, gradeClass;
    
    if (percentage >= 90) {
        grade = 'Excellent!';
        gradeClass = 'excellent';
    } else if (percentage >= 80) {
        grade = 'Good!';
        gradeClass = 'good';
    } else if (percentage >= 70) {
        grade = 'Average';
        gradeClass = 'average';
    } else {
        grade = 'Needs Improvement';
        gradeClass = 'poor';
    }
    
    document.querySelector('.score-display').innerHTML = `
        <p>You scored <strong>${score}</strong> out of <strong>${questions.length}</strong> questions correctly.</p>
        <p>Percentage: <strong>${percentage}%</strong></p>
        <p class="grade ${gradeClass}">${grade}</p>
    `;
    
    // Generate summary
    const categoryStats = generateCategoryStats();
    document.querySelector('.summary').innerHTML = `
        <h3>Performance by Category:</h3>
        ${categoryStats}
    `;
}

function generateCategoryStats() {
    const categories = {};
    
    // Group questions by category
    questions.forEach((question, index) => {
        if (!categories[question.category]) {
            categories[question.category] = { total: 0, correct: 0 };
        }
        categories[question.category].total++;
        if (userAnswers[index] === question.correctAnswer) {
            categories[question.category].correct++;
        }
    });
    
    // Generate HTML for each category
    let html = '';
    for (const [category, stats] of Object.entries(categories)) {
        const percentage = Math.round((stats.correct / stats.total) * 100);
        html += `<p><strong>${category}:</strong> ${stats.correct}/${stats.total} (${percentage}%)</p>`;
    }
    
    return html;
}

function hideResults() {
    questionSection.style.display = 'block';
    resultsSection.style.display = 'none';
}

function restartQuiz() {
    startQuiz();
}

function reviewAnswers() {
    hideResults();
    currentQuestionIndex = 0;
    showQuestion();
    updateProgress();
    updateButtons();
    
    // Show all answers for review
    questions.forEach((question, index) => {
        if (userAnswers[index] !== null) {
            // We'll show the answer when user navigates to each question
        }
    });
}

// Study Notes functionality
function initializeStudyNotes() {
    // Add smooth scrolling for table of contents links
    document.querySelectorAll('.table-of-contents a').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href');
            const targetElement = document.querySelector(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth' });
            }
        });
    });
}

// Initialize study notes when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeStudyNotes();
});
